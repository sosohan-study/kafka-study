# 카프카 핵심 개념 

카프카는 높은 처리량, 빠른 응답 속도, 높은 안정성 이라는 특징을 가지고 있다.   
하지만, 카프카가 왜 그렇게 안정적인지 그리고 어떻게 높은 처리량을 갖게 되었는지  
이와 관련된 구체적인 내용들은 잘 알려지지 않았다.     

## 분산 시스템 
분산 시스템은 **네트워크상에서 연결된 컴퓨터들의 그룹을 말한다.**    
단일 시스템이 갖지 못한 높은 성능을 목표로 여러 컴퓨터들을 통해 작업을 처리한다.     
  
이러한 분산 시스템의 장점은 높은 처리량과 더불어 장애 대응이 탁월하며   
부하가 높은 경우에는 시스템 확장까지 용이하다는 장점도 있다.    
  
카프카 또한, 분산 시스템이므로        
최초 구성한 클러스터의 리소스가 한계치에 도달해 더욱 높은 메시지 처리량이 필요한 경우      
브로커를 추가하는 방식으로 확장이 가능하다.(간단하며 많이 추가해도 된다.)     

이렇게 확장이 용이하다는 점은 카프카의 매우 큰 장점이다.   

## 페이지 캐시 
카프카는 높은 처리량을 높이기 위해 **페이지 캐시를 이용한다.**      
운영체제에서 성능을 높이기 위해 페이지 캐시를 적극 활용한다.        
카프카 역시 OS의 페이지 캐시를 활용하는 방식으로 설계되어있다.    
    
가상 메모리 기법으로 인하여 디스크를 읽고 쓰는 작업이 진행되는데 디스크 I/O는 속도가 느리다는 단점이 있다.        
이를 해결하기 위해, 메모리의 일부에 디스크 페이지 데이터를 저장하는 방식을 채택했고 이것이 바로 페이지 캐시이다.  
  
카프카, 페이지 캐시, 디스크의 읽고 쓰기는 위와 같다.     
카프카가 OS의 페이지 캐시를 이용한다는 것은       
카프카가 직접 디스크에서 읽고 쓰기를 하지 않고 **페이지 캐시를 통해서 읽고 쓰기를 한다고 이해하면 된다.**    

## 배치 전송 처리 
 
카프카는 `프로듀서`, `컨슈머 클라이언트`들과 서로 소통하며, 이들 사이에서 수많은 메시지를 주고 받는다.   
이때 발생하는 수많은 통신을 묶어서 처리한다면 단건 통신에 비해 네트워크 오버헤드를 줄일 수 있고     
장기적으로는 더욱 빠르고 효율적인 처리를 지원해줄 수 있을 것이다.     
 
온라인 상품 구매 프로세스에서 `상품의 재고 수량 업데이트 작업`과 `구매 로그를 저장소로 보내는 작업`을 예로 들겠다.     
상품의 재고 수량 업데이트 작업은 지연없이 실시간으로 처리돼야 하지만,     
구매 로그를 저장소로 보내는 작업은 이미 로그가 서버에 기록되어 있으므로 실시간보다는 배치 처리를 이용하는편이 효율적이다.   
카프카는 이러한 장점을 지닌 배치 전송을 권장한다.   
  
## 압축 전송  
  
카프카는 메시지 전송시 좀 더 성능이 높은 압축 전송을 권장한다.     
`gzip`, `snappy`, `lz4`, `zstd`등의 압축을 지원한다.    
  
압축만으로도 네트워크 대역폭이나 회선 비용등을 줄 일 수 있는데, 배치와 결합한다면 더욱 시너지를 얻는다.   
파일 하나를 압축하는 것보다는 수십개를 압축하고 배치 처리로 전송하는게 효율적이기 때문이다.   

* 높은 압축률 : gzip, zstd
* 빠른 응답속도 : lz4, snappy
   
하지만, 메시지의 형식이나 크기에 따라 결과가 상이하므로 실제로 테스트해보고 결정하는 것이 좋다.   

## 토픽, 파티션, 오프셋 

카프카는 **토픽이라는 곳에 데이터를 저장한다.(이메일 주소정도로 이해)**         
토픽은 병렬 처리를 위해 여러개의 파티션이라는 단위로 다시 나뉜다.        
카프카에서는 이와 같은 파티셔닝을 통해 단 하나의 토픽이라도 높은 처리략을 수행할 수 있다.     
 
파티션의 메시지가 저장되는 위치를 **오프셋**이라 부르며       
오프셋은 순차적으로 증가하는 숫자 형태로 되어 있다.     

![topic_01](https://user-images.githubusercontent.com/50267433/148417007-a7aef42d-8597-48d9-9c92-796f48eefcf6.png)  
  
하나의 토픽이 총3개로 나뉘어지며, 프로듀서부터 전송되는 메시지들의 쓰기 동작이 각 파티션별로 이뤄짐을 볼 수 있다.        
파티션마다 0부터 시작하여 증가하는 숫자가 존재하는데 이것이 오프셋이다.       
각 파티션의 오프셋은 고유하며, 메시지의 순서를 보장하고 컨슈머에서는 마지막까지 읽은 위치를 알 수 있다.    

## 고가용성 보장 

카프카는 분산 시스템이기 때문에 하나의 서버나 노드가 다운되어도        
다른 서버 또는 노드가 장애가 발생한 서버의 역할을 대신해 안적적인 서비스가 가능하다.         
이러한 고가용성을 보장학디 위해 카프카에서는 리플리케이션 기능을 제공한다.   

카프카에서 제공하는 리플리케이션 기능은 토픽 자체를 복제하는 것이 아니라 토픽의 파티션을 복제하는 것이다.     
토픽을 생성할 때 옵션으로 리플리케이션 팩터 수를 지정할 수 있으며, 이 숫자에 따라 리플리케이션들이 존재하게 된다.    

|리플리케이션 팩터 수|리더 수|팔로워 수|
|---------------|-----|-------|
|2|1|1|
|3|1|2|
|4|1|3|

원본과 리플리케이션을 구분하기 위해 흔히 `마스터`, `미러` 같은 용어를 사용하는데 카프카에서는 `리더`와 `팔로워`라고 부른다.     
위 표와 같이 팩터수가 증가함에 따라 리더는 1로 고정되지만, 팔로워 수가 증가되는 것을 볼 수 있다.   

일반적으로, 팔로워수가 많아지면 좋을 것이라 생각할 수 있지만   
팔로워의 수만큼 브로커의 디스크 공간도 소비되고 작업 리소스도 많아지므로 적정선의 팩터를 선정하는 것이 좋다.(3 추천)   
   
리더는 프로듀서 컨슈머로부터 오는 모든 읽기와 쓰기 요청을 처리하며   
팔로워는 오직 리더로부터 리플리케이션하게 된다.     
  
## 주키퍼 의존성  
 
주키퍼는 하둡의 서브 프로젝트 중 하나 출발해 하나의 탑레벨 프로젝트로 승격되었다.         
카프카를 비롯해 여러 아파치 산하 분산 애플리케이션에서 코디네이터 역할을 하고 있다.     
        
주키퍼는 여러 대의 서버를 앙상블(클러스터)로 구성하고,            
살아있는 노드 수가 과반수 이상 유지된다면 지속적인 서비스가 가능한 구조이다.          
따라서 주키퍼는 반드시 홀수로 구성해야한다.(절반이면 유지가 안되기 때문에 짝수는 안된다.)        
       
znode 를 이용해 카프카의 메타 정보가 주키퍼에 기록되며    
주키퍼는 이러한 znode를 이용해 브로커의 노드 관리, 토픽 관리, 컨트롤러 관리 등 매우 중요한 역할을 하고 있다.         
하지만 근시일내에 카프카에서 주키퍼 의존성을 제거된 버전이 릴리스될 예정이다.        
지금은 카프카의 중요한 메타 데이터를 저장하고 각 브로커를 관리하는 역할을 하는 것으로만 알고 넘어가자     
